#include <SDL2/SDL.h>
#include <fstream>
#include <iostream>
#include <random>
#include <string>
#include "json.hpp"

using json = nlohmann::json;

struct Cell {
    int x;
    int y;
};

struct Shape {
    int width;
    int height;
    std::vector<Cell> cells;
};

// ------------------------------------------------------------
// Load a shape from JSON
// ------------------------------------------------------------
Shape load_shape(const json& jshape) {
    Shape s;
    s.width = jshape["size"]["w"];
    s.height = jshape["size"]["h"];

    for (auto& c : jshape["cells"]) {
        s.cells.push_back({ c["x"], c["y"] });
    }
    return s;
}

// ------------------------------------------------------------
// Main Program
// ------------------------------------------------------------
int main(int argc, char* argv[]) {
    // ----------------------------------------------
    // Choose pattern (optional: command line)
    // ----------------------------------------------
    std::string choice = "glider";
    if (argc > 1)
        choice = argv[1];

    // ----------------------------------------------
    // Load JSON file
    // ----------------------------------------------
    std::ifstream file("patterns.json");
    if (!file.is_open()) {
        std::cerr << "ERROR: Could not open patterns.json\n";
        return 1;
    }

    json data;
    file >> data;

    if (!data.contains("shapes") || !data["shapes"].contains(choice)) {
        std::cerr << "ERROR: Shape not found: " << choice << "\n";
        return 1;
    }

    Shape shape = load_shape(data["shapes"][choice]);

    // ----------------------------------------------
    // SDL Initialization
    // ----------------------------------------------
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        std::cerr << "SDL Init Error: " << SDL_GetError() << "\n";
        return 1;
    }

    const int windowWidth  = 800;
    const int windowHeight = 600;
    const int cellSize     = 20;

    SDL_Window* window = SDL_CreateWindow(
        ("Pattern: " + choice).c_str(),
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        windowWidth,
        windowHeight,
        SDL_WINDOW_SHOWN
    );

    if (!window) {
        std::cerr << "Window Error: " << SDL_GetError() << "\n";
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(
        window, -1, SDL_RENDERER_ACCELERATED
    );

    if (!renderer) {
        std::cerr << "Renderer Error: " << SDL_GetError() << "\n";
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // ----------------------------------------------
    // Random Color for shape
    // ----------------------------------------------
    std::random_device rd;
    std::mt19937       gen(rd());
    std::uniform_int_distribution<int> dist(50, 255);

    int r = dist(gen);
    int g = dist(gen);
    int b = dist(gen);

    // ----------------------------------------------
    // Compute centered offset
    // ----------------------------------------------
    int patternPixelW = shape.width * cellSize;
    int patternPixelH = shape.height * cellSize;

    int offsetX = (windowWidth  - patternPixelW) / 2;
    int offsetY = (windowHeight - patternPixelH) / 2;

    // ----------------------------------------------
    // Main Loop
    // ----------------------------------------------
    bool running = true;
    SDL_Event event;

    while (running) {

        // Handle events
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT)
                running = false;

            if (event.type == SDL_KEYDOWN &&
                event.key.keysym.sym == SDLK_ESCAPE)
                running = false;
        }

        // Clear screen (dark gray)
        SDL_SetRenderDrawColor(renderer, 20, 20, 25, 255);
        SDL_RenderClear(renderer);

        // Draw shape with random color
        SDL_SetRenderDrawColor(renderer, r, g, b, 255);

        for (auto& c : shape.cells) {
            SDL_Rect rect;
            rect.x = offsetX + c.x * cellSize;
            rect.y = offsetY + c.y * cellSize;
            rect.w = cellSize;
            rect.h = cellSize;

            SDL_RenderFillRect(renderer, &rect);
        }

        SDL_RenderPresent(renderer);
        SDL_Delay(16); // ~60 FPS
    }

    // Cleanup
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
